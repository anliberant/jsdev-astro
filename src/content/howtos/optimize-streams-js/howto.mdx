---
title: 'How to Use JavaScript Streams for Efficient Asynchronous Requests'
slug: optimize-streams-js
heading: Using JavaScript Streams for Async Requests
icon: /icons/javascript.png
image: /icon.png
permalink: howto/optimize-streams-js
date: 2025-01-03
author: anton liberant
category: javascript
type: howto
tags: ['streams', 'async']
desc: Learn to work efficiently with JavaScript streams using promises, async/await, and iterators. Optimize data flow and performance with practical examples and tips.
---

## Introduction to JavaScript Asynchronous Programming

Asynchronous programming in JavaScript is essential for handling concurrent operations effectively, improving code readability, and ensuring a seamless user experience. This tutorial covers streams, async/await, promises, iterators, and best practices for high-performance asynchronous workflows.

## JavaScript's Single-Threaded Nature

JavaScript runs on a single thread, meaning long operations block the main thread.

```js
function longTask() {
  const end = Date.now() + 3000;
  while (Date.now() < end) {}
  console.log('Task complete');
}
console.log('Start');
longTask();
console.log('End');
```

This freezes the UI. To fix this, JavaScript uses the event loop + async programming.

## Core Async Tools

### Callbacks

```js
function fetchData(cb) {
  setTimeout(() => cb('Data received'), 2000);
}
fetchData(console.log);
```

Callback hell makes this hard to maintain.

### Promises

```js
function fetchData() {
  return new Promise(resolve =>
    setTimeout(() => resolve('Data received'), 2000)
  );
}
fetchData().then(console.log);
```

Parallel tasks:

```js
Promise.all([task1(), task2()]);
```

### Async/Await

```js
async function load() {
  const data = await fetchData();
  console.log(data);
}
load();
```

Parallel:

```js
const [a,b] = await Promise.all([t1(), t2()]);
```

## Streams & Async Iterators

Streams allow processing data chunk by chunk.

```js
async function* streamData() {
  yield 'chunk 1';
  yield 'chunk 2';
}
for await (const part of streamData()) {
  console.log(part);
}
```

**Use cases:**

- reading large files  
- network streaming  
- paginated API batches  

## Conclusion

Mastering async tools—including streams, promises, and async iterators—helps developers build responsive, scalable applications.