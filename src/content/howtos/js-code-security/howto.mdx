---
title: "How to Improve JavaScript Code Security"
slug: js-code-security
heading: "Strengthening JavaScript Security in Modern Web Applications"
icon: /icons/javascript.png
image: ./images/js-code-security.png
permalink: howto/js-code-security
date: 2025-01-28
author: anton liberant
category: javascript
type: howto
tags: ['security', 'xss', 'csrf']
desc: A practical guide to improving JavaScript security, preventing XSS and CSRF attacks, securing cookies, encrypting data, and maintaining safer modern applications.
---

JavaScript remains at the center of modern web development, powering both client-side interfaces and server-side systems through technologies like Node.js. Its ubiquity also makes it a common target for attackers. Weak input handling, insecure cookies, vulnerable dependencies, and outdated patterns can expose applications to XSS, CSRF, data theft, and more.

This article explores key areas of JavaScript security with practical, modern strategies to reduce vulnerabilities. The focus is on clarity, long-term maintainability, and real-world defensive techniques.

## 1. Preventing XSS Attacks

Cross-Site Scripting (XSS) is one of the most widespread vulnerabilities. It occurs when attackers manage to execute malicious JavaScript in a user’s browser.

### Avoid Direct HTML Injection

Never pass untrusted data into `innerHTML`:

```js
// Unsafe
output.innerHTML = userInput;

// Safe
output.textContent = userInput;
```

### Sanitize HTML Responsibly

If rendering user-provided HTML is necessary, sanitize it:

```js
import DOMPurify from "dompurify";

const safeHtml = DOMPurify.sanitize(userHtml);
content.innerHTML = safeHtml;
```

### Enforce Content Security Policy

A strong CSP prevents inline scripts and blocks unauthorized sources:

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;
```

CSP remains one of the strongest protections against XSS, especially for large-scale applications.

## 2. Defending Against CSRF Attacks

CSRF forces authenticated users to perform unintended actions. The attack manipulates the user’s browser into sending requests automatically.

### Use Anti-CSRF Tokens

Tokens should be unique per session and validated server-side:

```html
<form method="POST" action="/update">
  <input type="hidden" name="csrf_token" value="{{ csrfToken }}">
</form>
```

### Validate Origin or Referer

Server-side verification adds another protective layer:

```js
if (req.headers.origin !== "https://example.com") {
  return res.status(403).send("Blocked as untrusted origin");
}
```

## 3. Securing Cookies

Cookies store sensitive authentication data. If attackers access them, accounts can be hijacked.

### Always Use HttpOnly, Secure and SameSite

```js
res.cookie("session", token, {
  httpOnly: true,
  secure: true,
  sameSite: "Strict",
});
```

- `HttpOnly`: inaccessible through JavaScript  
- `Secure`: sent only over HTTPS  
- `SameSite`: prevents CSRF-related cookie forwarding  

Together they offer strong session protection.

## 4. Encrypting Sensitive Data

Security is not only about preventing attacks—it’s about protecting stored and transferred data.

### Enforce HTTPS

All traffic involving user information must use TLS:

```bash
sudo certbot --nginx -d example.com
```

### Hash Passwords Properly

Never store passwords in plaintext:

```js
import bcrypt from "bcrypt";

const hashed = await bcrypt.hash(password, 12);
```

### Use JWT Carefully

JWTs must be signed securely and expire:

```js
import jwt from "jsonwebtoken";

const token = jwt.sign({ id: userId }, process.env.JWT_SECRET, {
  expiresIn: "1h",
});
```

Avoid storing JWTs in `localStorage` if possible; prefer `HttpOnly` cookies.

## 5. Maintaining Safe Dependencies

A significant portion of vulnerabilities comes from outdated packages.

### Audit Regularly

```bash
npm audit fix
```

### Limit Dependencies

The fewer packages, the fewer potential attack vectors.

### Prefer Actively Maintained Libraries

Libraries without updates for years are inherently high-risk.

## 6. Using Automated Security Tools

Specialized tools help detect threats earlier in development cycles.

### Recommended Tools

- **Snyk** — dependency scanning + suggested patches  
- **ESLint security plugin** — catches insecure patterns  
- **OWASP ZAP** — penetration testing for web apps  

Using these tools continuously ensures high baseline security.

## 7. Secure Coding Patterns

Adopting certain patterns significantly reduces attack surfaces.

### Avoid `eval`, `new Function`, and Inline Scripts

These allow arbitrary code execution.

### Validate All Inputs Server-Side

Even if validated client-side, never trust browser data.

### Use `Object.freeze` for Critical Config Data

```js
const config = Object.freeze({
  apiBase: "/api/v1",
});
```

This prevents tampering in long-lived browser sessions.

## 8. Handling Sensitive Data in Memory

Some environments leak data unintentionally through logs or debugging tools.

### Never Log Sensitive Information

```js
// ❌ Do not log tokens
console.log("jwt", user.jwt);
```

### Use Environment Variables Correctly

Store secrets outside source code.

## Conclusion

Improving JavaScript security is not a one-time task but a continuous responsibility. By defending against XSS and CSRF, securing cookies, encrypting data, auditing dependencies, and adopting modern safe coding patterns, you establish a strong baseline for protecting users and infrastructure.

Security grows with discipline—review practices regularly, integrate automated tools, and stay updated with evolving threats. Robust JavaScript security starts with small, consistent, well‑informed decisions.