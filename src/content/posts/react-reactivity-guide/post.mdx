---
title: 'Master Reactivity in React: Derivations, Effects, and State Synch'
slug: react-reactivity-guide
heading: 'The React Reactivity Model: Mastering Derivations, Effects and State Synchronization'
image: ./images/react-reactivity-guide.png
permalink: react-reactivity-guide
date: 2025-04-17
author: anton liberant
category: react
type: post
tags: ['reactivity', 'state']
desc: 'Master Reactâ€™s reactivity concepts: state derivations, effects, and sync patterns. Avoid common pitfalls and build more predictable, maintainable React apps.'
---

In the world of React, reactivity often feels like a second-class citizen. We rely on `useEffect` for side effects, `useMemo` for optimization, and `useState` for everything elseâ€”but how do these pieces actually work together? What happens when state changes ripple through a component tree? And more importantly, how can we write reactive logic that's both correct and efficient?

In this deep dive, weâ€™ll explore the fundamentals of reactive systemsâ€”derivations, effects, and synchronizationâ€”through the lens of React. Inspired by concepts from frameworks like SolidJS and MobX, weâ€™ll reframe these ideas using only idiomatic React, helping you understand why and when things re-render, and how to write better, cleaner state-driven components.

## ğŸ§  Derivations vs Effects in React

Letâ€™s start with two key reactive patterns:

### âœ³ï¸ Derivations with `useMemo`

A derivation is a value calculated from other state. In React, you use `useMemo`:

```jsx
const [name, setName] = useState('John');
const upperName = useMemo(() => name.toUpperCase(), [name]);
```

This is a pure transformation. It never triggers side effects or updates stateâ€”it just reacts to inputs.

### ğŸ” Synchronization with `useEffect`

By contrast, this is synchronization logic:

```jsx
const [name, setName] = useState('John');
const [upperName, setUpperName] = useState('');

useEffect(() => {
  setUpperName(name.toUpperCase());
}, [name]);
```

This updates one state based on another, but it risks timing bugs and unnecessary renders. Derived values should ideally be expressed with `useMemo`.

### âš ï¸ Why Derivations Are Safer

Reactâ€™s `useEffect` runs after render, so updating state inside effects may cause double renders, stale values, or UI flickers.

Using `useMemo` instead of setting derived state with `useEffect` avoids these issues and keeps logic pure and consistent.

### ğŸ•¸ï¸ Deriving from Multiple Values

Letâ€™s build a dependency graph in React. Weâ€™ll mimic this structure:

```bash
a â”€â–¶ b â”€â”
â”‚       â”‚
â”‚       â–¼
â””â”€â”€â”€â”€â–¶ c â”€â–¶ d â”€â–¶ e
        â–²
        â”‚
       b
```

### ğŸ” What Weâ€™ll Build

- `a`: source state
- `b`, `c`: derived from `a`
- `d`: derived from `c`
- `e`: derived from `b` and `d`

All derivations are done with `useMemo`.

## âœ… Full React Example (No Signals)

```jsx
import { useEffect, useMemo, useState } from 'react';

export default function App() {
  const [a, setA] = useState(1);

  const b = useMemo(() => a + 1, [a]);
  const c = useMemo(() => a + 1, [a]);
  const d = useMemo(() => c + 1, [c]);
  const e = useMemo(() => b + d, [b, d]);

  useEffect(() => {
    console.log('e =', e); // Only runs when b or d changes
  }, [e]);

  return (
    <div className='text-gray-800 p-4 font-sans'>
      <h1 className='mb-2 text-xl font-bold'>React Derivation Example</h1>
      <div className='space-y-2'>
        <div>a: {a}</div>
        <div>b (a + 1): {b}</div>
        <div>c (a + 1): {c}</div>
        <div>d (c + 1): {d}</div>
        <div>e (b + d): {e}</div>
      </div>
      <button
        onClick={() => setA(prev => prev + 1)}
        className='mt-4 rounded bg-blue-600 px-4 py-2 text-white'
      >
        Increment a
      </button>
    </div>
  );
}
```

### âœ… What This Code Demonstrates

- `b`, `c`, `d`, `e` are all derived from `a` â€” purely with `useMemo`
- No unnecessary `useEffect` logic for state syncing
- Reactâ€™s dependency tracking ensures correct evaluation order

### ğŸ”€ Pull-Based Reactivity in React

React is **pull-based**. Components pull data when they render. This works well for derivations via `useMemo`, but Reactâ€™s `useEffect` is asynchronous, which can be dangerous for direct state-to-state syncs.

Instead of:

```js
useEffect(() => {
  setX(transform(y));
}, [y]);
```

Prefer:

```js
const x = useMemo(() => transform(y), [y]);
```

This avoids redundant updates and lets React optimize.

## ğŸ’¡ Summary

- âœ… Prefer `useMemo` for derived values
- âŒ Avoid `useEffect` to sync state unless necessary
- âš™ï¸ React is pull-based, and benefits from pure derivation logic

## Final Thoughts

Reactivity isn't just about updating the UIâ€”itâ€™s about maintaining consistency, optimizing performance, and ensuring predictable behavior across your components. While Reactâ€™s approach to reactivity differs from fine-grained systems like Solid or Svelte, understanding the underlying principlesâ€”derivations, synchronization, and the flow of updatesâ€”empowers you to make better architectural decisions.

By modeling derived values properly, avoiding unnecessary effects, and respecting Reactâ€™s render cycle, you can write code thatâ€™s not only cleaner but also more resilient. The more you understand how reactive data flowsâ€”from signals to state, from memoized values to effectsâ€”the more you'll be able to harness Reactâ€™s power effectively.

This was just the beginning. In the next part, weâ€™ll dig into lazy vs eager computations, and how you can use techniques like memoization and selector composition to build even more optimized reactive trees in React.

Stay tunedâ€”and keep your components consistent.
